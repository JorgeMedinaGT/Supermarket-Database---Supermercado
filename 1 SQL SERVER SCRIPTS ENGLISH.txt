CREATE DATABASE SUPERMARKET_PROJECT2025;

USE SUPERMARKET_PROJECT2025;

-- HUMAN RESOURCES TABLE
CREATE TABLE HUMAN_RESOURCES (
    HR_DEPT_ID INT NOT NULL,
    CONSTRAINT PK_HUMAN_RESOURCES PRIMARY KEY (HR_DEPT_ID)
);

-- POSITION TABLE
CREATE TABLE POSITION (
    POSITION_ID INT NOT NULL,
    POSITION_TITLE NVARCHAR(100) NOT NULL,
    BASE_SALARY DECIMAL(10,2),
    DESCRIPTION NVARCHAR(MAX),
    HR_DEPT_ID INT NOT NULL,
    CONSTRAINT PK_POSITION PRIMARY KEY (POSITION_ID),
    CONSTRAINT FK_POSITION_HUMAN_RESOURCES FOREIGN KEY (HR_DEPT_ID) REFERENCES HUMAN_RESOURCES(HR_DEPT_ID)
);

-- EMPLOYEE TABLE
CREATE TABLE EMPLOYEE (
    EMPLOYEE_ID INT NOT NULL,
    POSITION_ID INT NOT NULL,
    FIRST_NAME NVARCHAR(100) NOT NULL,
    BONUSES DECIMAL(10,2),
    EMAIL NVARCHAR(255),
    PHONE NVARCHAR(50),
    NATIONALITY NVARCHAR(50),
    HIRE_DATE DATE NOT NULL,
    CONSTRAINT PK_EMPLOYEE PRIMARY KEY (EMPLOYEE_ID),
    CONSTRAINT FK_EMPLOYEE_POSITION FOREIGN KEY (POSITION_ID) REFERENCES POSITION(POSITION_ID)
);

-- CUSTOMER SERVICE ORDER TABLE
CREATE TABLE CUSTOMER_SERVICE_ORDER (
    CS_ORDER_ID INT NOT NULL,
    EMPLOYEE_ID INT NOT NULL,
    CUSTOMER_ID INT NOT NULL,
    ORDER_DATETIME DATETIME NOT NULL,
    DETAILS NVARCHAR(MAX),
    CONSTRAINT PK_CUSTOMER_SERVICE_ORDER PRIMARY KEY (CS_ORDER_ID),
    CONSTRAINT FK_CS_ORDER_EMPLOYEE FOREIGN KEY (EMPLOYEE_ID) REFERENCES EMPLOYEE(EMPLOYEE_ID),
    CONSTRAINT FK_CS_ORDER_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER(CUSTOMER_ID) -- PLACEHOLDER
);

-- SATISFACTION_BY_ORDER TABLE
CREATE TABLE SATISFACTION_BY_ORDER (
    CS_ORDER_ID INT NOT NULL,
    HIGH_RATING BIT NOT NULL,
    LOW_RATING BIT NOT NULL,
    MEDIUM_RATING BIT NOT NULL,
    NO_RESPONSE BIT NOT NULL,
    CONSTRAINT PK_SATISFACTION PRIMARY KEY (CS_ORDER_ID),
    CONSTRAINT FK_SATISFACTION_ORDER FOREIGN KEY (CS_ORDER_ID) REFERENCES CUSTOMER_SERVICE_ORDER(CS_ORDER_ID)
); -- Note: The foreign key is also a primary key, 1-to-1 relationship

-- CUSTOMER TABLE
CREATE TABLE CUSTOMER (
    CUSTOMER_ID INT NOT NULL,
    NIT NVARCHAR(50) NOT NULL,
    FIRST_NAME NVARCHAR(100) NOT NULL,
    LAST_NAME NVARCHAR(100),
    ADDRESS NVARCHAR(255),
    PHONE NVARCHAR(20),
    EMAIL NVARCHAR(100),
    CONSTRAINT PK_CUSTOMER PRIMARY KEY (CUSTOMER_ID)
);

-- CUSTOMER_TYPE TABLE
CREATE TABLE CUSTOMER_TYPE (
    CUSTOMER_TYPE_ID INT NOT NULL,
    CUSTOMER_ID INT NOT NULL,
    OCCASIONAL BIT NOT NULL,
    REGULAR BIT NOT NULL,
    IMPORTANT_CUSTOMER BIT NOT NULL,
    CONSTRAINT PK_CUSTOMER_TYPE PRIMARY KEY (CUSTOMER_TYPE_ID),
    CONSTRAINT FK_CUSTOMER_TYPE_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER(CUSTOMER_ID)
);

-- SALES_INVOICE TABLE
CREATE TABLE SALES_INVOICE (
    SALES_INVOICE_ID INT NOT NULL,
    CUSTOMER_ID INT NOT NULL,
    ISSUE_DATE DATE NOT NULL,
    TOTAL_AMOUNT DECIMAL(10,2) NOT NULL,
    CONSTRAINT PK_SALES_INVOICE PRIMARY KEY (SALES_INVOICE_ID),
    CONSTRAINT FK_SALES_INVOICE_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER(CUSTOMER_ID)
);

-- SALES_INVOICE_DETAIL TABLE (ASSOCIATIVE BETWEEN SALES_INVOICE AND PRODUCT)
CREATE TABLE SALES_INVOICE_DETAIL (
    SALES_INVOICE_ID INT NOT NULL,
    PRODUCT_ID INT NOT NULL,
    QUANTITY INT NOT NULL,
    UNIT_PRICE DECIMAL(10,2) NOT NULL,
    SUBTOTAL DECIMAL(10,2) NOT NULL,
    CONSTRAINT PK_SALES_INVOICE_DETAIL PRIMARY KEY (SALES_INVOICE_ID, PRODUCT_ID), -- NOTE: COMPOSITE KEY: Without this, there would be no rule preventing the insertion of two identical rows (identical SALES_INVOICE_ID and PRODUCT_ID). This could lead to database integrity issues, such as incorrect total calculations or inconsistencies in records. It serves to ensure that each invoice and product combination is unique. This approach works well for associative tables in many-to-many relationships.
    CONSTRAINT FK_SALES_INVOICE_DETAIL_INVOICE FOREIGN KEY (SALES_INVOICE_ID) REFERENCES SALES_INVOICE(SALES_INVOICE_ID),
    CONSTRAINT FK_SALES_INVOICE_DETAIL_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID)
);

-- NOTE: The alternative (effective and valid depending on the case) to a composite key is a single primary key for the associative entity (provides scalability and ease), but the composite key is efficient if the following is sought:
	-- Uniqueness between two entities: If you want to ensure that a specific combination (e.g., an invoice with a product) is not repeated, a composite primary key is ideal.
    -- Optimization for direct relationships: When foreign keys also act as primary attributes (record identity), using a composite key simplifies certain validations, such as preventing duplicates.

-- CATEGORY TABLE
CREATE TABLE CATEGORY (
    CATEGORY_ID INT NOT NULL,
    CATEGORY_NAME NVARCHAR(100) NOT NULL,
    DESCRIPTION NVARCHAR(MAX),
    CONSTRAINT PK_CATEGORY PRIMARY KEY (CATEGORY_ID)
);

-- PRODUCT TABLE
CREATE TABLE PRODUCT (
    PRODUCT_ID INT NOT NULL,
    PRODUCT_NAME NVARCHAR(100) NOT NULL,
    PRICE DECIMAL(10,2) NOT NULL,
    CATEGORY_ID INT NOT NULL,
    CONSTRAINT PK_PRODUCT PRIMARY KEY (PRODUCT_ID),
    CONSTRAINT FK_PRODUCT_CATEGORY FOREIGN KEY (CATEGORY_ID) REFERENCES CATEGORY(CATEGORY_ID)
);

-- WAREHOUSE TABLE
CREATE TABLE WAREHOUSE (
    WAREHOUSE_ID INT NOT NULL,
    WAREHOUSE_NAME NVARCHAR(100) NOT NULL,
    LOCATION NVARCHAR(255),
    CONSTRAINT PK_WAREHOUSE PRIMARY KEY (WAREHOUSE_ID)
);

-- INVENTORY TABLE
CREATE TABLE INVENTORY (
    PRODUCT_ID INT NOT NULL,
    WAREHOUSE_ID INT NOT NULL,
    STOCK_QUANTITY INT NOT NULL,
    CONSTRAINT PK_INVENTORY PRIMARY KEY (PRODUCT_ID, WAREHOUSE_ID),
    CONSTRAINT FK_INVENTORY_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID),
    CONSTRAINT FK_INVENTORY_WAREHOUSE FOREIGN KEY (WAREHOUSE_ID) REFERENCES WAREHOUSE(WAREHOUSE_ID)
);

-- CAMPAIGN TABLE
CREATE TABLE CAMPAIGN (
    CAMPAIGN_ID INT NOT NULL,
    CAMPAIGN_NAME NVARCHAR(100) NOT NULL,
    START_DATE DATE NOT NULL,
    END_DATE DATE NOT NULL,
    BUDGET DECIMAL(10,2) NOT NULL,
    PROMOTION_MEDIUM NVARCHAR(100),
    CONSTRAINT PK_CAMPAIGN PRIMARY KEY (CAMPAIGN_ID)
);

-- Note: Following global conventions, many developers prefer to avoid special characters in table, column, or constraint names to prevent conflicts in future integrations or migrations between systems.

-- PROMOTION TABLE
CREATE TABLE PROMOTION (
    PROMOTION_ID INT NOT NULL,
    DISCOUNT_PERCENTAGE DECIMAL(5,2) NOT NULL,
    POLICIES NVARCHAR(MAX),
    PRODUCT_ID INT NOT NULL,
    CAMPAIGN_ID INT NOT NULL,
    CONSTRAINT PK_PROMOTION PRIMARY KEY (PROMOTION_ID),
    CONSTRAINT FK_PROMOTION_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID),
    CONSTRAINT FK_PROMOTION_CAMPAIGN FOREIGN KEY (CAMPAIGN_ID) REFERENCES CAMPAIGN(CAMPAIGN_ID)
);

-- SUPPLIER TABLE
CREATE TABLE SUPPLIER (
    SUPPLIER_ID INT NOT NULL,
    SUPPLIER_NAME NVARCHAR(100) NOT NULL,
    PHONE NVARCHAR(50),
    EMAIL NVARCHAR(100),
    ADDRESS NVARCHAR(255),
    TAX_ID NVARCHAR(50),
    CONSTRAINT PK_SUPPLIER PRIMARY KEY (SUPPLIER_ID)
);

-- PURCHASE_INVOICE TABLE
CREATE TABLE PURCHASE_INVOICE (
    PURCHASE_INVOICE_ID INT NOT NULL,
    SUPPLIER_ID INT NOT NULL,
    CREATION_DATE DATE NOT NULL,
    DELIVERY_DATE DATE,
    TOTAL_AMOUNT DECIMAL(10,2) NOT NULL,
    CONSTRAINT PK_PURCHASE_INVOICE PRIMARY KEY (PURCHASE_INVOICE_ID),
    CONSTRAINT FK_PURCHASE_INVOICE_SUPPLIER FOREIGN KEY (SUPPLIER_ID) REFERENCES SUPPLIER(SUPPLIER_ID)
);

-- PURCHASE_INVOICE_DETAIL TABLE
CREATE TABLE PURCHASE_INVOICE_DETAIL (
    PURCHASE_INVOICE_ID INT NOT NULL,
    PRODUCT_ID INT NOT NULL,
    QUANTITY INT NOT NULL,
    UNIT_PRICE DECIMAL(10,2) NOT NULL,
    SUBTOTAL DECIMAL(10,2) NOT NULL,
    CONSTRAINT PK_PURCHASE_INVOICE_DETAIL PRIMARY KEY (PURCHASE_INVOICE_ID, PRODUCT_ID),
    CONSTRAINT FK_PURCHASE_INVOICE_DETAIL_INVOICE FOREIGN KEY (PURCHASE_INVOICE_ID) REFERENCES PURCHASE_INVOICE(PURCHASE_INVOICE_ID),
    CONSTRAINT FK_PURCHASE_INVOICE_DETAIL_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID)
);
